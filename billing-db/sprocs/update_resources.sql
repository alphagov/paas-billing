-- Do not run too far back in time or will take too long to update resources during which time users won't be able to generate billing reports
CREATE OR REPLACE FUNCTION update_resources()
RETURNS TABLE
(
    num_rows_added INT
)
LANGUAGE plpgsql AS $$
DECLARE _from_date TIMESTAMPTZ;
DECLARE _run_date TIMESTAMPTZ := NOW();
DECLARE _num_rows_added INT;
DECLARE _max_compose_event_processed INT;
DECLARE _max_app_event_processed INT;
DECLARE _max_service_event_processed INT;
DECLARE _process_name TEXT := 'Cloud Foundry event collector';
BEGIN
    -- Events are source of truth. Do not 'fix' or manually update the resources table since running this stored function will delete those changes. Having this code take account of any manual changes in resources risks opening us up to lots of edge cases where we may get corrupted records in resources.

    DROP TABLE IF EXISTS resources_new;
    DROP TABLE IF EXISTS events_temp;
    DROP TABLE IF EXISTS raw_events;
    DROP TABLE IF EXISTS raw_events_with_injected_values;
    DROP TABLE IF EXISTS event_ranges;

    -- Grab all app and service events into a temp table. Later, we can filter these.

    -- Start of modified code from create_events.sql.
    CREATE TEMPORARY TABLE events_temp (
        event_guid uuid PRIMARY KEY NOT NULL,
        resource_guid uuid NOT NULL,
        resource_name text NOT NULL,
        resource_type text NOT NULL,
        org_guid uuid NOT NULL,
        org_name text NOT NULL,
        org_quota_definition_guid uuid NOT NULL,
        space_guid uuid NOT NULL,
        space_name text NOT NULL,
        duration tstzrange NOT NULL,
        plan_guid uuid NOT NULL,
        plan_name text NOT NULL,
        service_guid uuid,
        service_name text,
        number_of_nodes integer,
        memory_in_mb integer,
        storage_in_mb integer,

        CONSTRAINT duration_must_not_be_empty CHECK (not isempty(duration))
    );

    CREATE TEMPORARY TABLE raw_events
    (
        event_row INT GENERATED BY DEFAULT AS IDENTITY,
        next_event_row INT,
        row_updated BOOLEAN DEFAULT FALSE,
        event_sequence INT,
        event_guid UUID,
        event_type TEXT,
        created_at TIMESTAMPTZ,
        resource_guid UUID,
        resource_name TEXT,
        resource_type TEXT,
        org_guid UUID,
        space_guid UUID,
        plan_guid UUID,
        plan_name TEXT,
        service_guid UUID,
        service_name TEXT,
        number_of_nodes NUMERIC,
        memory_in_mb NUMERIC,
        storage_in_mb NUMERIC,
        -- state resource_state NULL,
        state resource_state -- state from the *_usage_events table
    );

    IF NOT EXISTS (SELECT * FROM process_lock WHERE process_name = _process_name) THEN
        RAISE EXCEPTION 'No entry exists in the process_lock table for the process: "%"', _process_name;
    END IF;

    -- Single-thread Cloud Foundry event collector (force only one instance of update_resources to run at a given time).
    UPDATE process_lock SET process_running = TRUE
    WHERE  process_name = _process_name;

    -- Get the latest events that will be processed by this update_resources call. This does not prevent events from being added while this instance of update_resources is running, which is fine. Any events added after the next three statements have been run will be processed the next time update_resources is run.
    SELECT MAX(id) INTO _max_compose_event_processed
    FROM   compose_audit_events;

    SELECT MAX(id) INTO _max_service_event_processed
    FROM   service_usage_events;

    SELECT MAX(id) INTO _max_app_event_processed
    FROM   app_usage_events;

    DROP TABLE IF EXISTS app_guid_to_process;
    DROP TABLE IF EXISTS service_guid_to_process;
    DROP TABLE IF EXISTS task_guid_to_process;
    DROP TABLE IF EXISTS staging_guid_to_process;

    CREATE TEMP TABLE app_guid_to_process (
       guid UUID PRIMARY KEY
    );

    CREATE TEMP TABLE service_guid_to_process (
       guid UUID PRIMARY KEY
    );

    CREATE TEMP TABLE task_guid_to_process (
       guid UUID PRIMARY KEY
    );

    CREATE TEMP TABLE staging_guid_to_process (
	guid UUID PRIMARY KEY
    );

    INSERT INTO app_guid_to_process (
	guid
    )
    SELECT DISTINCT(a.raw_message->>'app_guid')::uuid as guid FROM app_usage_events a WHERE a.processed = FALSE
 	AND (a.raw_message->>'state' = 'STARTED' OR a.raw_message->>'state' = 'STOPPED')
        AND a.raw_message->>'space_name' !~ '^(SMOKE|ACC|CATS|PERF|BACC|AIVENBACC|ASATS)-';
    


    INSERT INTO service_guid_to_process (
	guid
    )
    SELECT DISTINCT (s.raw_message->>'service_instance_guid')::uuid as guid  FROM service_usage_events s WHERE s.processed = FALSE
	AND s.raw_message->>'service_instance_type' = 'managed_service_instance'
        AND s.raw_message->>'space_name' !~ '^(SMOKE|ACC|CATS|PERF|BACC|AIVENBACC|ASATS)-';

    INSERT INTO task_guid_to_process (
       guid
    )
    SELECT DISTINCT (a.raw_message->>'task_guid')::uuid as guid  FROM app_usage_events a WHERE a.processed = FALSE
	AND (a.raw_message->>'state' = 'TASK_STARTED' OR a.raw_message->>'state' = 'TASK_STOPPED')
        AND a.raw_message->>'space_name' !~ '^(SMOKE|ACC|CATS|PERF|BACC|AIVENBACC|ASATS)-';

    INSERT INTO staging_guid_to_process (
	guid
    )
    SELECT DISTINCT (a.raw_message->>'parent_app_guid')::uuid  FROM app_usage_events a WHERE a.processed = FALSE
        AND (a.raw_message->>'state' = 'STAGING_STARTED' OR a.raw_message->>'state' = 'STAGING_STOPPED')
	AND a.raw_message->>'space_name' !~ '^(SMOKE|ACC|CATS|PERF|BACC|AIVENBACC|ASATS)-' ;




    -- ****************************
    -- IMPORTANT NOTE: the created_at is the date that is used in old/new billing to provide the valid_from and valid_to fields in the resources table. Therefore, we are using this as
    --                 the cut-off date for processing here. This date does not necessarily match the date/time in which events arrive from Cloud Foundry. If we need to process events
    --                 in the order in which they arrive then we would need to add a new timestamp field to the various event tables and set the value to NOW() when events are added.
    --                 We could then use this new timestamp field to feed into the valid_from and valid_to fields in the resources table.
    -- ****************************

    -- Get the earliest created_at

    INSERT INTO raw_events
    (
        event_sequence,
        event_guid,
        event_type,
        created_at,
        resource_guid,
        resource_name,
        resource_type,
        org_guid,
        space_guid,
        plan_guid,
        plan_name,
        service_guid,
        service_name,
        number_of_nodes,
        memory_in_mb,
        storage_in_mb,
        state -- state from the *_usage_events table
    )
    SELECT      id as event_sequence,
                guid::uuid as event_guid,
                'app' as event_type,
                created_at,
                (raw_message->>'app_guid')::uuid as resource_guid,
                (raw_message->>'app_name') as resource_name,
                'app'::text as resource_type,                              -- resource_type for compute resources
                (raw_message->>'org_guid')::uuid as org_guid,
                (raw_message->>'space_guid')::uuid as space_guid,
                'f4d4b95a-f55e-4593-8d54-3364c25798c4'::uuid as plan_guid, -- plan guid for all compute resources
                'app'::text as plan_name,                                  -- plan name for all compute resources
                '4f6f0a18-cdd4-4e51-8b6b-dc39b696e61b'::uuid as service_guid,
                'app'::text as service_name,
                coalesce(raw_message->>'instance_count', '1')::numeric as number_of_nodes,
                coalesce(raw_message->>'memory_in_mb_per_instance', '0')::numeric as memory_in_mb,
                '0'::numeric as storage_in_mb,
                (raw_message->>'state')::resource_state as state
            from
                app_usage_events
            where (raw_message->>'state' = 'STARTED' or raw_message->>'state' = 'STOPPED')
            AND raw_message->>'space_name' !~ '^(SMOKE|ACC|CATS|PERF|BACC|AIVENBACC|ASATS)-' -- FIXME: this is open to abuse
            AND guid::uuid in (select * FROM app_guid_to_process)
            AND id <= _max_app_event_processed
    union all (
            select
                id as event_sequence,
                guid::uuid as event_guid,
                'service' as event_type,
                created_at,
                (raw_message->>'service_instance_guid')::uuid as resource_guid,
                (raw_message->>'service_instance_name') as resource_name,
                'service' as resource_type,
                (raw_message->>'org_guid')::uuid as org_guid,
                (raw_message->>'space_guid')::uuid as space_guid,
                (raw_message->>'service_plan_guid')::uuid as plan_guid,
                CONCAT((raw_message->>'service_label'), ' ', (raw_message->>'service_plan_name')) as plan_name,
                (raw_message->>'service_guid')::uuid as service_guid,
                (raw_message->>'service_label') as service_name,
                NULL::numeric as number_of_nodes,
                NULL::numeric as memory_in_mb,
                NULL::numeric as storage_in_mb,
                (case
                    when (raw_message->>'state') = 'CREATED' then 'STARTED'
                    when (raw_message->>'state') = 'DELETED' then 'STOPPED'
                    when (raw_message->>'state') = 'UPDATED' then 'STARTED'
                end)::resource_state as state
            from
                service_usage_events
            where raw_message->>'service_instance_type' = 'managed_service_instance'
            AND raw_message->>'space_name' !~ '^(SMOKE|ACC|CATS|PERF|BACC|AIVENBACC|ASATS)-' -- FIXME: this is open to abuse
            AND guid::uuid in (select * FROM service_guid_to_process)
            AND id <= _max_service_event_processed
    ) union all (
            select
                id as event_sequence,
                guid::uuid as event_guid,
                'task' as event_type,
                created_at,
                (raw_message->>'task_guid')::uuid as resource_guid,
                (raw_message->>'task_name') as resource_name,
                'task'::text as resource_type,                              -- resource_type for task resources
                (raw_message->>'org_guid')::uuid as org_guid,
                (raw_message->>'space_guid')::uuid as space_guid,
                'ebfa9453-ef66-450c-8c37-d53dfd931038'::uuid as plan_guid,  -- plan guid for all task resources
                'task'::text as plan_name,                                  -- plan name for all task resources
                '4f6f0a18-cdd4-4e51-8b6b-dc39b696e61b'::uuid as service_guid,
                'app'::text as service_name,
                coalesce(raw_message->>'instance_count', '1')::numeric as number_of_nodes,
                coalesce(raw_message->>'memory_in_mb_per_instance', '0')::numeric as memory_in_mb,
                '0'::numeric as storage_in_mb,
                (case
                    when (raw_message->>'state') = 'TASK_STARTED' then 'STARTED'
                    when (raw_message->>'state') = 'TASK_STOPPED' then 'STOPPED'
                end)::resource_state as state
            from
                app_usage_events
            where (raw_message->>'state' = 'TASK_STARTED' or raw_message->>'state' = 'TASK_STOPPED')
            AND raw_message->>'space_name' !~ '^(SMOKE|ACC|CATS|PERF|BACC|AIVENBACC|ASATS)-' -- FIXME: this is open to abuse
            AND guid::uuid in (SELECT * FROM task_guid_to_process)
            AND id <= _max_app_event_processed
    ) union all (
            select
                id as event_sequence,
                guid::uuid as event_guid,
                'staging' as event_type,
                created_at,
                (raw_message->>'parent_app_guid')::uuid as resource_guid,
                (raw_message->>'parent_app_name') as resource_name,
                'app'::text as resource_type,                              -- resource_type for staging of resources
                (raw_message->>'org_guid')::uuid as org_guid,
                (raw_message->>'space_guid')::uuid as space_guid,
                '9d071c77-7a68-4346-9981-e8dafac95b6f'::uuid as plan_guid,  -- plan guid for all staging of resources
                'staging'::text as plan_name,                                  -- plan name for all staging of resources
                '4f6f0a18-cdd4-4e51-8b6b-dc39b696e61b'::uuid as service_guid,
                'app'::text as service_name,
                '1'::numeric as number_of_nodes,
                coalesce(raw_message->>'memory_in_mb_per_instance', '0')::numeric as memory_in_mb,
                '0'::numeric as storage_in_mb,
                (case
                    when (raw_message->>'state') = 'STAGING_STARTED' then 'STARTED'
                    when (raw_message->>'state') = 'STAGING_STOPPED' then 'STOPPED'
                end)::resource_state as state
            from
                app_usage_events
            where (raw_message->>'state' = 'STAGING_STARTED' or raw_message->>'state' = 'STAGING_STOPPED')
            AND raw_message->>'space_name' !~ '^(SMOKE|ACC|CATS|PERF|BACC|AIVENBACC|ASATS)-' -- FIXME: this is open to abuse
            AND guid::uuid in (SELECT * FROM staging_guid_to_process)
            AND id <= _max_app_event_processed
    ) union all (
            select
                s.id as event_sequence,
                uuid_generate_v4() as event_guid,
                'service' as event_type,
                c.created_at::timestamptz as created_at,
                substring(
                    c.raw_message->'data'->>'deployment'
                    from '[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$'
                )::uuid as resource_guid,
                (case
                    when s.created_at > c.created_at then (s.raw_message->>'service_instance_name')
                    else NULL::text
                end) as resource_name,
                'service'::text as resource_type,
                (s.raw_message->>'org_guid')::uuid as org_guid,
                (s.raw_message->>'space_guid')::uuid as space_guid,
                (s.raw_message->>'service_plan_guid')::uuid as plan_guid,
                CONCAT((s.raw_message->>'service_label'), ' ', (s.raw_message->>'service_plan_name')) as plan_name,
                (s.raw_message->>'service_guid')::uuid as service_guid,
                (s.raw_message->>'service_label') as service_name,
                NULL::numeric as number_of_nodes,
                (pg_size_bytes(c.raw_message->'data'->>'memory') / 1024 / 1024)::numeric as memory_in_mb,
                (pg_size_bytes(c.raw_message->'data'->>'storage') / 1024 / 1024)::numeric as storage_in_mb,
                'STARTED'::resource_state as state
            from
                compose_audit_events c
            left join
                service_usage_events s
            on
                s.raw_message->>'service_instance_guid' = substring(
                    c.raw_message->'data'->>'deployment'
                    from '[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$'
                ) AND s.raw_message->>'state' = 'CREATED'
            where s.raw_message->>'space_name' !~ '^(SMOKE|ACC|CATS|PERF|BACC|AIVENBACC|ASATS)-' -- FIXME: this is open to abuse;
            AND c.created_at >= _from_date
            AND c.id <= _max_compose_event_processed
    )
    ORDER BY created_at DESC, event_sequence DESC;

    CREATE INDEX raw_events_event_row1 ON raw_events (event_row);

    CREATE INDEX raw_events_event_row2 ON raw_events (resource_guid, event_type, event_row);

    

    -- The ordering in the identity column in raw_events should follow the same ordering as on created_at, event_sequence

    CREATE TEMPORARY TABLE raw_events_with_injected_values
    AS
    SELECT
        event_sequence,
        event_guid,
        event_type,
        created_at,
        resource_guid,
        coalesce(
            resource_name,
            (array_remove(
                array_agg(resource_name) OVER prev_events
            , NULL))[1]
        ) AS resource_name,
        resource_type,
        org_guid,
        space_guid,
        plan_guid,
        plan_name,
        service_guid,
        service_name,
        number_of_nodes,
        coalesce(
            memory_in_mb,
            (array_remove(
                array_agg(memory_in_mb) OVER prev_events
            , NULL))[1]
        ) AS memory_in_mb,
        coalesce(
            storage_in_mb,
            (array_remove(
                array_agg(storage_in_mb) OVER prev_events
            , NULL))[1]
        ) AS storage_in_mb,
        state
    FROM
        raw_events
    window
        prev_events AS (
            PARTITION BY resource_guid, event_type
            ORDER BY created_at DESC, event_sequence DESC
            ROWS BETWEEN current ROW AND UNBOUNDED FOLLOWING
        )
    ORDER BY
        created_at, event_sequence;

    CREATE TEMPORARY TABLE event_ranges AS
    SELECT *,
           tstzrange(created_at,
                     lead(created_at, 1, CASE WHEN event_type = 'staging' THEN created_at ELSE '9999-12-31T23:59:59Z' END) OVER resource_states
           ) AS duration
    FROM raw_events_with_injected_values
    WINDOW resource_states AS (
        PARTITION BY resource_guid, event_type
        ORDER BY created_at, event_sequence
        ROWS BETWEEN current ROW AND 1 FOLLOWING
    );

    INSERT INTO events_temp WITH
    valid_service_plans as (
        select
            *,
            tstzrange(valid_from, lead(valid_from, 1, 'infinity') over (
                partition by guid order by valid_from rows between current row and 1 following
            )) as valid_for
        from
            service_plans
    ),
    valid_services as (
        select
            *,
            tstzrange(valid_from, lead(valid_from, 1, 'infinity') over (
                partition by guid order by valid_from rows between current row and 1 following
            )) as valid_for
        from
            services
    ),
    valid_orgs as (
        select
            *,
            tstzrange(valid_from, lead(valid_from, 1, 'infinity') over (
                partition by guid order by valid_from rows between current row and 1 following
            )) as valid_for
        from
            orgs
    ),
    valid_spaces as (
        select
            *,
            tstzrange(valid_from, lead(valid_from, 1, 'infinity') over (
                partition by guid order by valid_from rows between current row and 1 following
            )) as valid_for
        from
            spaces
    )
    select
        event_guid,
        resource_guid,
        resource_name,
        resource_type,
        org_guid,
        coalesce(vo.name, org_guid::text) as org_name,
        coalesce(vo.quota_definition_guid, org_guid) as org_quota_definition_guid,
        space_guid,
        coalesce(vspace.name, space_guid::text) as space_name,
        duration,
        (case
            when resource_type = 'service'
            then coalesce(uuid_or_placeholder(vsp.unique_id), 'd5091c33-2f9d-4b15-82dc-4ad69717fc03')::uuid
            else plan_guid
        end) as plan_guid,
        coalesce(plan_name, vsp.name) as plan_name,
        coalesce(vs.guid, ev.service_guid) as service_guid,
        coalesce(vs.label, ev.service_name) as service_name,
        number_of_nodes,
        memory_in_mb,
        storage_in_mb
    from
        event_ranges ev
    left join
        valid_service_plans vsp on ev.plan_guid = vsp.guid
        and upper(ev.duration) <@ vsp.valid_for -- Check that UPPER(ev.duration) is within the date/time range given by vsp.valid_for
    left join
        valid_services vs on vsp.service_guid = vs.guid
        and upper(ev.duration) <@ vs.valid_for
    left join
        valid_orgs vo on ev.org_guid = vo.guid
        and upper(ev.duration) <@ vo.valid_for
    left join
        valid_spaces vspace on ev.space_guid = vspace.guid
        and upper(ev.duration) <@ vspace.valid_for
    where
        state = 'STARTED'
        and not isempty(duration)
    order by
        event_sequence, event_guid;
    -- End of modified code from create_events.sql

    CREATE TEMPORARY TABLE resources_new
    AS
    SELECT *
    FROM   resources
    WHERE  1=2;

    INSERT INTO resources_new
    (
        valid_from,
        valid_to,
        resource_guid,
        resource_name,
        resource_type,
        org_guid,
        org_name,
        org_quota_definition_guid,
        space_guid,
        space_name,
        plan_name,
        plan_guid,
        number_of_nodes,
        memory_in_mb,
        storage_in_mb,
        cf_event_guid,
        last_updated
    )
    SELECT DISTINCT LOWER(duration) AS "valid_from",
        UPPER(duration) AS "valid_to",
        resource_guid,
        resource_name,
        resource_type,
        org_guid,
        org_name,
        org_quota_definition_guid,
        space_guid,
        space_name,
        plan_name,
        plan_guid,
        number_of_nodes,
        memory_in_mb,
        storage_in_mb,
        event_guid AS "cf_event_guid", -- Is this the event that gave rise to the last change in the resources row? Need to check this. If so, may be useful to keep this, otherwise remove this field
        NOW()
    FROM events_temp
    WHERE LOWER(duration) >= _from_date;

    -- Delete any records for resources that are being updated.
    DELETE FROM resources
    WHERE  (resources.resource_type = 'app' AND resource_guid in (SELECT * FROM app_guid_to_process))
    OR (resources.resource_type = 'service' AND resource_guid in (SELECT * FROM service_guid_to_process))
    OR (resources.resource_type = 'task' AND resource_guid in (SELECT * FROM task_guid_to_process))
    OR (resources.resource_type = 'staging' AND resource_guid in (SELECT * FROM staging_guid_to_process));
    -- Close off any records with valid_to >= _from_date in resources
    UPDATE resources SET valid_to = t.valid_to
    FROM   resources_new t
    WHERE  resources.resource_guid = t.resource_guid
    AND    resources.valid_from = t.valid_from -- The valid_from dates will align if the history in resources is correct and noone has manually changed the app_usage_events/service_usage_events tables. If someone has manually changed resources then it is difficult to detect and we would need to run this stored function from before the times in resources that have been changed to refresh the whole history in resources.
    -- The following are not needed for functionality, but may be helpful to Postgres depending on indices.
    AND    resources.valid_to >= _from_date
    AND    t.valid_to >= _from_date;

    WITH inserted_entries AS (
        INSERT INTO resources
        (
            valid_from,
            valid_to,
            resource_guid,
            resource_name,
            resource_type,
            org_guid,
            org_name,
            org_quota_definition_guid,
            space_guid,
            space_name,
            plan_name,
            plan_guid,
            number_of_nodes,
            memory_in_mb,
            storage_in_mb,
            cf_event_guid,
            last_updated
        )
        SELECT	valid_from,
                valid_to,
                resource_guid,
                resource_name,
                resource_type,
                org_guid,
                org_name,
                org_quota_definition_guid,
                space_guid,
                space_name,
                plan_name,
                plan_guid,
                number_of_nodes,
                memory_in_mb,
                storage_in_mb,
                cf_event_guid,
                _run_date
        FROM   resources_new
        WHERE  valid_from >= _from_date
        RETURNING *
    )
    SELECT COUNT(*) INTO _num_rows_added FROM inserted_entries;

    UPDATE app_usage_events SET processed = TRUE
    WHERE  id <= _max_app_event_processed
    AND    processed IS FALSE;

    UPDATE service_usage_events SET processed = TRUE
    WHERE  id <= _max_service_event_processed
    AND    processed IS FALSE;

    UPDATE compose_audit_events SET processed = TRUE
    WHERE  id <= _max_compose_event_processed
    AND    processed IS FALSE;

    UPDATE process_lock SET process_running = FALSE
    WHERE  process_name = _process_name;

    RETURN QUERY
    SELECT _num_rows_added AS num_rows_added;
END
$$;
