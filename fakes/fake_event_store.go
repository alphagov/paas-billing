// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"context"
	"sync"

	"github.com/alphagov/paas-billing/eventio"
)

type FakeEventStore struct {
	ConsolidateStub        func(eventio.EventFilter) error
	consolidateMutex       sync.RWMutex
	consolidateArgsForCall []struct {
		arg1 eventio.EventFilter
	}
	consolidateReturns struct {
		result1 error
	}
	consolidateReturnsOnCall map[int]struct {
		result1 error
	}
	ConsolidateAllStub        func() error
	consolidateAllMutex       sync.RWMutex
	consolidateAllArgsForCall []struct {
	}
	consolidateAllReturns struct {
		result1 error
	}
	consolidateAllReturnsOnCall map[int]struct {
		result1 error
	}
	ConsolidateFullMonthsStub        func(string, string) error
	consolidateFullMonthsMutex       sync.RWMutex
	consolidateFullMonthsArgsForCall []struct {
		arg1 string
		arg2 string
	}
	consolidateFullMonthsReturns struct {
		result1 error
	}
	consolidateFullMonthsReturnsOnCall map[int]struct {
		result1 error
	}
	ForecastBillableEventRowsStub        func(context.Context, []eventio.UsageEvent, eventio.EventFilter) (eventio.BillableEventRows, error)
	forecastBillableEventRowsMutex       sync.RWMutex
	forecastBillableEventRowsArgsForCall []struct {
		arg1 context.Context
		arg2 []eventio.UsageEvent
		arg3 eventio.EventFilter
	}
	forecastBillableEventRowsReturns struct {
		result1 eventio.BillableEventRows
		result2 error
	}
	forecastBillableEventRowsReturnsOnCall map[int]struct {
		result1 eventio.BillableEventRows
		result2 error
	}
	ForecastBillableEventsStub        func([]eventio.UsageEvent, eventio.EventFilter) ([]eventio.BillableEvent, error)
	forecastBillableEventsMutex       sync.RWMutex
	forecastBillableEventsArgsForCall []struct {
		arg1 []eventio.UsageEvent
		arg2 eventio.EventFilter
	}
	forecastBillableEventsReturns struct {
		result1 []eventio.BillableEvent
		result2 error
	}
	forecastBillableEventsReturnsOnCall map[int]struct {
		result1 []eventio.BillableEvent
		result2 error
	}
	GetBillableEventRowsStub        func(context.Context, eventio.EventFilter) (eventio.BillableEventRows, error)
	getBillableEventRowsMutex       sync.RWMutex
	getBillableEventRowsArgsForCall []struct {
		arg1 context.Context
		arg2 eventio.EventFilter
	}
	getBillableEventRowsReturns struct {
		result1 eventio.BillableEventRows
		result2 error
	}
	getBillableEventRowsReturnsOnCall map[int]struct {
		result1 eventio.BillableEventRows
		result2 error
	}
	GetBillableEventsStub        func(eventio.EventFilter) ([]eventio.BillableEvent, error)
	getBillableEventsMutex       sync.RWMutex
	getBillableEventsArgsForCall []struct {
		arg1 eventio.EventFilter
	}
	getBillableEventsReturns struct {
		result1 []eventio.BillableEvent
		result2 error
	}
	getBillableEventsReturnsOnCall map[int]struct {
		result1 []eventio.BillableEvent
		result2 error
	}
	GetConsolidatedBillableEventRowsStub        func(context.Context, eventio.EventFilter) (eventio.BillableEventRows, error)
	getConsolidatedBillableEventRowsMutex       sync.RWMutex
	getConsolidatedBillableEventRowsArgsForCall []struct {
		arg1 context.Context
		arg2 eventio.EventFilter
	}
	getConsolidatedBillableEventRowsReturns struct {
		result1 eventio.BillableEventRows
		result2 error
	}
	getConsolidatedBillableEventRowsReturnsOnCall map[int]struct {
		result1 eventio.BillableEventRows
		result2 error
	}
	GetConsolidatedBillableEventsStub        func(eventio.EventFilter) ([]eventio.BillableEvent, error)
	getConsolidatedBillableEventsMutex       sync.RWMutex
	getConsolidatedBillableEventsArgsForCall []struct {
		arg1 eventio.EventFilter
	}
	getConsolidatedBillableEventsReturns struct {
		result1 []eventio.BillableEvent
		result2 error
	}
	getConsolidatedBillableEventsReturnsOnCall map[int]struct {
		result1 []eventio.BillableEvent
		result2 error
	}
	GetCurrencyRatesStub        func(eventio.TimeRangeFilter) ([]eventio.CurrencyRate, error)
	getCurrencyRatesMutex       sync.RWMutex
	getCurrencyRatesArgsForCall []struct {
		arg1 eventio.TimeRangeFilter
	}
	getCurrencyRatesReturns struct {
		result1 []eventio.CurrencyRate
		result2 error
	}
	getCurrencyRatesReturnsOnCall map[int]struct {
		result1 []eventio.CurrencyRate
		result2 error
	}
	GetEventsStub        func(eventio.RawEventFilter) ([]eventio.RawEvent, error)
	getEventsMutex       sync.RWMutex
	getEventsArgsForCall []struct {
		arg1 eventio.RawEventFilter
	}
	getEventsReturns struct {
		result1 []eventio.RawEvent
		result2 error
	}
	getEventsReturnsOnCall map[int]struct {
		result1 []eventio.RawEvent
		result2 error
	}
	GetPricingPlansStub        func(eventio.TimeRangeFilter) ([]eventio.PricingPlan, error)
	getPricingPlansMutex       sync.RWMutex
	getPricingPlansArgsForCall []struct {
		arg1 eventio.TimeRangeFilter
	}
	getPricingPlansReturns struct {
		result1 []eventio.PricingPlan
		result2 error
	}
	getPricingPlansReturnsOnCall map[int]struct {
		result1 []eventio.PricingPlan
		result2 error
	}
	GetTotalCostStub        func() ([]eventio.TotalCost, error)
	getTotalCostMutex       sync.RWMutex
	getTotalCostArgsForCall []struct {
	}
	getTotalCostReturns struct {
		result1 []eventio.TotalCost
		result2 error
	}
	getTotalCostReturnsOnCall map[int]struct {
		result1 []eventio.TotalCost
		result2 error
	}
	GetUsageEventRowsStub        func(eventio.EventFilter) (eventio.UsageEventRows, error)
	getUsageEventRowsMutex       sync.RWMutex
	getUsageEventRowsArgsForCall []struct {
		arg1 eventio.EventFilter
	}
	getUsageEventRowsReturns struct {
		result1 eventio.UsageEventRows
		result2 error
	}
	getUsageEventRowsReturnsOnCall map[int]struct {
		result1 eventio.UsageEventRows
		result2 error
	}
	GetUsageEventsStub        func(eventio.EventFilter) ([]eventio.UsageEvent, error)
	getUsageEventsMutex       sync.RWMutex
	getUsageEventsArgsForCall []struct {
		arg1 eventio.EventFilter
	}
	getUsageEventsReturns struct {
		result1 []eventio.UsageEvent
		result2 error
	}
	getUsageEventsReturnsOnCall map[int]struct {
		result1 []eventio.UsageEvent
		result2 error
	}
	GetVATRatesStub        func(eventio.TimeRangeFilter) ([]eventio.VATRate, error)
	getVATRatesMutex       sync.RWMutex
	getVATRatesArgsForCall []struct {
		arg1 eventio.TimeRangeFilter
	}
	getVATRatesReturns struct {
		result1 []eventio.VATRate
		result2 error
	}
	getVATRatesReturnsOnCall map[int]struct {
		result1 []eventio.VATRate
		result2 error
	}
	InitStub        func() error
	initMutex       sync.RWMutex
	initArgsForCall []struct {
	}
	initReturns struct {
		result1 error
	}
	initReturnsOnCall map[int]struct {
		result1 error
	}
	IsRangeConsolidatedStub        func(eventio.EventFilter) (bool, error)
	isRangeConsolidatedMutex       sync.RWMutex
	isRangeConsolidatedArgsForCall []struct {
		arg1 eventio.EventFilter
	}
	isRangeConsolidatedReturns struct {
		result1 bool
		result2 error
	}
	isRangeConsolidatedReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	PingStub        func() error
	pingMutex       sync.RWMutex
	pingArgsForCall []struct {
	}
	pingReturns struct {
		result1 error
	}
	pingReturnsOnCall map[int]struct {
		result1 error
	}
	RefreshStub        func() error
	refreshMutex       sync.RWMutex
	refreshArgsForCall []struct {
	}
	refreshReturns struct {
		result1 error
	}
	refreshReturnsOnCall map[int]struct {
		result1 error
	}
	StoreEventsStub        func([]eventio.RawEvent) error
	storeEventsMutex       sync.RWMutex
	storeEventsArgsForCall []struct {
		arg1 []eventio.RawEvent
	}
	storeEventsReturns struct {
		result1 error
	}
	storeEventsReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeEventStore) Consolidate(arg1 eventio.EventFilter) error {
	fake.consolidateMutex.Lock()
	ret, specificReturn := fake.consolidateReturnsOnCall[len(fake.consolidateArgsForCall)]
	fake.consolidateArgsForCall = append(fake.consolidateArgsForCall, struct {
		arg1 eventio.EventFilter
	}{arg1})
	stub := fake.ConsolidateStub
	fakeReturns := fake.consolidateReturns
	fake.recordInvocation("Consolidate", []interface{}{arg1})
	fake.consolidateMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeEventStore) ConsolidateCallCount() int {
	fake.consolidateMutex.RLock()
	defer fake.consolidateMutex.RUnlock()
	return len(fake.consolidateArgsForCall)
}

func (fake *FakeEventStore) ConsolidateCalls(stub func(eventio.EventFilter) error) {
	fake.consolidateMutex.Lock()
	defer fake.consolidateMutex.Unlock()
	fake.ConsolidateStub = stub
}

func (fake *FakeEventStore) ConsolidateArgsForCall(i int) eventio.EventFilter {
	fake.consolidateMutex.RLock()
	defer fake.consolidateMutex.RUnlock()
	argsForCall := fake.consolidateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeEventStore) ConsolidateReturns(result1 error) {
	fake.consolidateMutex.Lock()
	defer fake.consolidateMutex.Unlock()
	fake.ConsolidateStub = nil
	fake.consolidateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeEventStore) ConsolidateReturnsOnCall(i int, result1 error) {
	fake.consolidateMutex.Lock()
	defer fake.consolidateMutex.Unlock()
	fake.ConsolidateStub = nil
	if fake.consolidateReturnsOnCall == nil {
		fake.consolidateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.consolidateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeEventStore) ConsolidateAll() error {
	fake.consolidateAllMutex.Lock()
	ret, specificReturn := fake.consolidateAllReturnsOnCall[len(fake.consolidateAllArgsForCall)]
	fake.consolidateAllArgsForCall = append(fake.consolidateAllArgsForCall, struct {
	}{})
	stub := fake.ConsolidateAllStub
	fakeReturns := fake.consolidateAllReturns
	fake.recordInvocation("ConsolidateAll", []interface{}{})
	fake.consolidateAllMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeEventStore) ConsolidateAllCallCount() int {
	fake.consolidateAllMutex.RLock()
	defer fake.consolidateAllMutex.RUnlock()
	return len(fake.consolidateAllArgsForCall)
}

func (fake *FakeEventStore) ConsolidateAllCalls(stub func() error) {
	fake.consolidateAllMutex.Lock()
	defer fake.consolidateAllMutex.Unlock()
	fake.ConsolidateAllStub = stub
}

func (fake *FakeEventStore) ConsolidateAllReturns(result1 error) {
	fake.consolidateAllMutex.Lock()
	defer fake.consolidateAllMutex.Unlock()
	fake.ConsolidateAllStub = nil
	fake.consolidateAllReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeEventStore) ConsolidateAllReturnsOnCall(i int, result1 error) {
	fake.consolidateAllMutex.Lock()
	defer fake.consolidateAllMutex.Unlock()
	fake.ConsolidateAllStub = nil
	if fake.consolidateAllReturnsOnCall == nil {
		fake.consolidateAllReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.consolidateAllReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeEventStore) ConsolidateFullMonths(arg1 string, arg2 string) error {
	fake.consolidateFullMonthsMutex.Lock()
	ret, specificReturn := fake.consolidateFullMonthsReturnsOnCall[len(fake.consolidateFullMonthsArgsForCall)]
	fake.consolidateFullMonthsArgsForCall = append(fake.consolidateFullMonthsArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.ConsolidateFullMonthsStub
	fakeReturns := fake.consolidateFullMonthsReturns
	fake.recordInvocation("ConsolidateFullMonths", []interface{}{arg1, arg2})
	fake.consolidateFullMonthsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeEventStore) ConsolidateFullMonthsCallCount() int {
	fake.consolidateFullMonthsMutex.RLock()
	defer fake.consolidateFullMonthsMutex.RUnlock()
	return len(fake.consolidateFullMonthsArgsForCall)
}

func (fake *FakeEventStore) ConsolidateFullMonthsCalls(stub func(string, string) error) {
	fake.consolidateFullMonthsMutex.Lock()
	defer fake.consolidateFullMonthsMutex.Unlock()
	fake.ConsolidateFullMonthsStub = stub
}

func (fake *FakeEventStore) ConsolidateFullMonthsArgsForCall(i int) (string, string) {
	fake.consolidateFullMonthsMutex.RLock()
	defer fake.consolidateFullMonthsMutex.RUnlock()
	argsForCall := fake.consolidateFullMonthsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeEventStore) ConsolidateFullMonthsReturns(result1 error) {
	fake.consolidateFullMonthsMutex.Lock()
	defer fake.consolidateFullMonthsMutex.Unlock()
	fake.ConsolidateFullMonthsStub = nil
	fake.consolidateFullMonthsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeEventStore) ConsolidateFullMonthsReturnsOnCall(i int, result1 error) {
	fake.consolidateFullMonthsMutex.Lock()
	defer fake.consolidateFullMonthsMutex.Unlock()
	fake.ConsolidateFullMonthsStub = nil
	if fake.consolidateFullMonthsReturnsOnCall == nil {
		fake.consolidateFullMonthsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.consolidateFullMonthsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeEventStore) ForecastBillableEventRows(arg1 context.Context, arg2 []eventio.UsageEvent, arg3 eventio.EventFilter) (eventio.BillableEventRows, error) {
	var arg2Copy []eventio.UsageEvent
	if arg2 != nil {
		arg2Copy = make([]eventio.UsageEvent, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.forecastBillableEventRowsMutex.Lock()
	ret, specificReturn := fake.forecastBillableEventRowsReturnsOnCall[len(fake.forecastBillableEventRowsArgsForCall)]
	fake.forecastBillableEventRowsArgsForCall = append(fake.forecastBillableEventRowsArgsForCall, struct {
		arg1 context.Context
		arg2 []eventio.UsageEvent
		arg3 eventio.EventFilter
	}{arg1, arg2Copy, arg3})
	stub := fake.ForecastBillableEventRowsStub
	fakeReturns := fake.forecastBillableEventRowsReturns
	fake.recordInvocation("ForecastBillableEventRows", []interface{}{arg1, arg2Copy, arg3})
	fake.forecastBillableEventRowsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeEventStore) ForecastBillableEventRowsCallCount() int {
	fake.forecastBillableEventRowsMutex.RLock()
	defer fake.forecastBillableEventRowsMutex.RUnlock()
	return len(fake.forecastBillableEventRowsArgsForCall)
}

func (fake *FakeEventStore) ForecastBillableEventRowsCalls(stub func(context.Context, []eventio.UsageEvent, eventio.EventFilter) (eventio.BillableEventRows, error)) {
	fake.forecastBillableEventRowsMutex.Lock()
	defer fake.forecastBillableEventRowsMutex.Unlock()
	fake.ForecastBillableEventRowsStub = stub
}

func (fake *FakeEventStore) ForecastBillableEventRowsArgsForCall(i int) (context.Context, []eventio.UsageEvent, eventio.EventFilter) {
	fake.forecastBillableEventRowsMutex.RLock()
	defer fake.forecastBillableEventRowsMutex.RUnlock()
	argsForCall := fake.forecastBillableEventRowsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeEventStore) ForecastBillableEventRowsReturns(result1 eventio.BillableEventRows, result2 error) {
	fake.forecastBillableEventRowsMutex.Lock()
	defer fake.forecastBillableEventRowsMutex.Unlock()
	fake.ForecastBillableEventRowsStub = nil
	fake.forecastBillableEventRowsReturns = struct {
		result1 eventio.BillableEventRows
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) ForecastBillableEventRowsReturnsOnCall(i int, result1 eventio.BillableEventRows, result2 error) {
	fake.forecastBillableEventRowsMutex.Lock()
	defer fake.forecastBillableEventRowsMutex.Unlock()
	fake.ForecastBillableEventRowsStub = nil
	if fake.forecastBillableEventRowsReturnsOnCall == nil {
		fake.forecastBillableEventRowsReturnsOnCall = make(map[int]struct {
			result1 eventio.BillableEventRows
			result2 error
		})
	}
	fake.forecastBillableEventRowsReturnsOnCall[i] = struct {
		result1 eventio.BillableEventRows
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) ForecastBillableEvents(arg1 []eventio.UsageEvent, arg2 eventio.EventFilter) ([]eventio.BillableEvent, error) {
	var arg1Copy []eventio.UsageEvent
	if arg1 != nil {
		arg1Copy = make([]eventio.UsageEvent, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.forecastBillableEventsMutex.Lock()
	ret, specificReturn := fake.forecastBillableEventsReturnsOnCall[len(fake.forecastBillableEventsArgsForCall)]
	fake.forecastBillableEventsArgsForCall = append(fake.forecastBillableEventsArgsForCall, struct {
		arg1 []eventio.UsageEvent
		arg2 eventio.EventFilter
	}{arg1Copy, arg2})
	stub := fake.ForecastBillableEventsStub
	fakeReturns := fake.forecastBillableEventsReturns
	fake.recordInvocation("ForecastBillableEvents", []interface{}{arg1Copy, arg2})
	fake.forecastBillableEventsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeEventStore) ForecastBillableEventsCallCount() int {
	fake.forecastBillableEventsMutex.RLock()
	defer fake.forecastBillableEventsMutex.RUnlock()
	return len(fake.forecastBillableEventsArgsForCall)
}

func (fake *FakeEventStore) ForecastBillableEventsCalls(stub func([]eventio.UsageEvent, eventio.EventFilter) ([]eventio.BillableEvent, error)) {
	fake.forecastBillableEventsMutex.Lock()
	defer fake.forecastBillableEventsMutex.Unlock()
	fake.ForecastBillableEventsStub = stub
}

func (fake *FakeEventStore) ForecastBillableEventsArgsForCall(i int) ([]eventio.UsageEvent, eventio.EventFilter) {
	fake.forecastBillableEventsMutex.RLock()
	defer fake.forecastBillableEventsMutex.RUnlock()
	argsForCall := fake.forecastBillableEventsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeEventStore) ForecastBillableEventsReturns(result1 []eventio.BillableEvent, result2 error) {
	fake.forecastBillableEventsMutex.Lock()
	defer fake.forecastBillableEventsMutex.Unlock()
	fake.ForecastBillableEventsStub = nil
	fake.forecastBillableEventsReturns = struct {
		result1 []eventio.BillableEvent
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) ForecastBillableEventsReturnsOnCall(i int, result1 []eventio.BillableEvent, result2 error) {
	fake.forecastBillableEventsMutex.Lock()
	defer fake.forecastBillableEventsMutex.Unlock()
	fake.ForecastBillableEventsStub = nil
	if fake.forecastBillableEventsReturnsOnCall == nil {
		fake.forecastBillableEventsReturnsOnCall = make(map[int]struct {
			result1 []eventio.BillableEvent
			result2 error
		})
	}
	fake.forecastBillableEventsReturnsOnCall[i] = struct {
		result1 []eventio.BillableEvent
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) GetBillableEventRows(arg1 context.Context, arg2 eventio.EventFilter) (eventio.BillableEventRows, error) {
	fake.getBillableEventRowsMutex.Lock()
	ret, specificReturn := fake.getBillableEventRowsReturnsOnCall[len(fake.getBillableEventRowsArgsForCall)]
	fake.getBillableEventRowsArgsForCall = append(fake.getBillableEventRowsArgsForCall, struct {
		arg1 context.Context
		arg2 eventio.EventFilter
	}{arg1, arg2})
	stub := fake.GetBillableEventRowsStub
	fakeReturns := fake.getBillableEventRowsReturns
	fake.recordInvocation("GetBillableEventRows", []interface{}{arg1, arg2})
	fake.getBillableEventRowsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeEventStore) GetBillableEventRowsCallCount() int {
	fake.getBillableEventRowsMutex.RLock()
	defer fake.getBillableEventRowsMutex.RUnlock()
	return len(fake.getBillableEventRowsArgsForCall)
}

func (fake *FakeEventStore) GetBillableEventRowsCalls(stub func(context.Context, eventio.EventFilter) (eventio.BillableEventRows, error)) {
	fake.getBillableEventRowsMutex.Lock()
	defer fake.getBillableEventRowsMutex.Unlock()
	fake.GetBillableEventRowsStub = stub
}

func (fake *FakeEventStore) GetBillableEventRowsArgsForCall(i int) (context.Context, eventio.EventFilter) {
	fake.getBillableEventRowsMutex.RLock()
	defer fake.getBillableEventRowsMutex.RUnlock()
	argsForCall := fake.getBillableEventRowsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeEventStore) GetBillableEventRowsReturns(result1 eventio.BillableEventRows, result2 error) {
	fake.getBillableEventRowsMutex.Lock()
	defer fake.getBillableEventRowsMutex.Unlock()
	fake.GetBillableEventRowsStub = nil
	fake.getBillableEventRowsReturns = struct {
		result1 eventio.BillableEventRows
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) GetBillableEventRowsReturnsOnCall(i int, result1 eventio.BillableEventRows, result2 error) {
	fake.getBillableEventRowsMutex.Lock()
	defer fake.getBillableEventRowsMutex.Unlock()
	fake.GetBillableEventRowsStub = nil
	if fake.getBillableEventRowsReturnsOnCall == nil {
		fake.getBillableEventRowsReturnsOnCall = make(map[int]struct {
			result1 eventio.BillableEventRows
			result2 error
		})
	}
	fake.getBillableEventRowsReturnsOnCall[i] = struct {
		result1 eventio.BillableEventRows
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) GetBillableEvents(arg1 eventio.EventFilter) ([]eventio.BillableEvent, error) {
	fake.getBillableEventsMutex.Lock()
	ret, specificReturn := fake.getBillableEventsReturnsOnCall[len(fake.getBillableEventsArgsForCall)]
	fake.getBillableEventsArgsForCall = append(fake.getBillableEventsArgsForCall, struct {
		arg1 eventio.EventFilter
	}{arg1})
	stub := fake.GetBillableEventsStub
	fakeReturns := fake.getBillableEventsReturns
	fake.recordInvocation("GetBillableEvents", []interface{}{arg1})
	fake.getBillableEventsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeEventStore) GetBillableEventsCallCount() int {
	fake.getBillableEventsMutex.RLock()
	defer fake.getBillableEventsMutex.RUnlock()
	return len(fake.getBillableEventsArgsForCall)
}

func (fake *FakeEventStore) GetBillableEventsCalls(stub func(eventio.EventFilter) ([]eventio.BillableEvent, error)) {
	fake.getBillableEventsMutex.Lock()
	defer fake.getBillableEventsMutex.Unlock()
	fake.GetBillableEventsStub = stub
}

func (fake *FakeEventStore) GetBillableEventsArgsForCall(i int) eventio.EventFilter {
	fake.getBillableEventsMutex.RLock()
	defer fake.getBillableEventsMutex.RUnlock()
	argsForCall := fake.getBillableEventsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeEventStore) GetBillableEventsReturns(result1 []eventio.BillableEvent, result2 error) {
	fake.getBillableEventsMutex.Lock()
	defer fake.getBillableEventsMutex.Unlock()
	fake.GetBillableEventsStub = nil
	fake.getBillableEventsReturns = struct {
		result1 []eventio.BillableEvent
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) GetBillableEventsReturnsOnCall(i int, result1 []eventio.BillableEvent, result2 error) {
	fake.getBillableEventsMutex.Lock()
	defer fake.getBillableEventsMutex.Unlock()
	fake.GetBillableEventsStub = nil
	if fake.getBillableEventsReturnsOnCall == nil {
		fake.getBillableEventsReturnsOnCall = make(map[int]struct {
			result1 []eventio.BillableEvent
			result2 error
		})
	}
	fake.getBillableEventsReturnsOnCall[i] = struct {
		result1 []eventio.BillableEvent
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) GetConsolidatedBillableEventRows(arg1 context.Context, arg2 eventio.EventFilter) (eventio.BillableEventRows, error) {
	fake.getConsolidatedBillableEventRowsMutex.Lock()
	ret, specificReturn := fake.getConsolidatedBillableEventRowsReturnsOnCall[len(fake.getConsolidatedBillableEventRowsArgsForCall)]
	fake.getConsolidatedBillableEventRowsArgsForCall = append(fake.getConsolidatedBillableEventRowsArgsForCall, struct {
		arg1 context.Context
		arg2 eventio.EventFilter
	}{arg1, arg2})
	stub := fake.GetConsolidatedBillableEventRowsStub
	fakeReturns := fake.getConsolidatedBillableEventRowsReturns
	fake.recordInvocation("GetConsolidatedBillableEventRows", []interface{}{arg1, arg2})
	fake.getConsolidatedBillableEventRowsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeEventStore) GetConsolidatedBillableEventRowsCallCount() int {
	fake.getConsolidatedBillableEventRowsMutex.RLock()
	defer fake.getConsolidatedBillableEventRowsMutex.RUnlock()
	return len(fake.getConsolidatedBillableEventRowsArgsForCall)
}

func (fake *FakeEventStore) GetConsolidatedBillableEventRowsCalls(stub func(context.Context, eventio.EventFilter) (eventio.BillableEventRows, error)) {
	fake.getConsolidatedBillableEventRowsMutex.Lock()
	defer fake.getConsolidatedBillableEventRowsMutex.Unlock()
	fake.GetConsolidatedBillableEventRowsStub = stub
}

func (fake *FakeEventStore) GetConsolidatedBillableEventRowsArgsForCall(i int) (context.Context, eventio.EventFilter) {
	fake.getConsolidatedBillableEventRowsMutex.RLock()
	defer fake.getConsolidatedBillableEventRowsMutex.RUnlock()
	argsForCall := fake.getConsolidatedBillableEventRowsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeEventStore) GetConsolidatedBillableEventRowsReturns(result1 eventio.BillableEventRows, result2 error) {
	fake.getConsolidatedBillableEventRowsMutex.Lock()
	defer fake.getConsolidatedBillableEventRowsMutex.Unlock()
	fake.GetConsolidatedBillableEventRowsStub = nil
	fake.getConsolidatedBillableEventRowsReturns = struct {
		result1 eventio.BillableEventRows
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) GetConsolidatedBillableEventRowsReturnsOnCall(i int, result1 eventio.BillableEventRows, result2 error) {
	fake.getConsolidatedBillableEventRowsMutex.Lock()
	defer fake.getConsolidatedBillableEventRowsMutex.Unlock()
	fake.GetConsolidatedBillableEventRowsStub = nil
	if fake.getConsolidatedBillableEventRowsReturnsOnCall == nil {
		fake.getConsolidatedBillableEventRowsReturnsOnCall = make(map[int]struct {
			result1 eventio.BillableEventRows
			result2 error
		})
	}
	fake.getConsolidatedBillableEventRowsReturnsOnCall[i] = struct {
		result1 eventio.BillableEventRows
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) GetConsolidatedBillableEvents(arg1 eventio.EventFilter) ([]eventio.BillableEvent, error) {
	fake.getConsolidatedBillableEventsMutex.Lock()
	ret, specificReturn := fake.getConsolidatedBillableEventsReturnsOnCall[len(fake.getConsolidatedBillableEventsArgsForCall)]
	fake.getConsolidatedBillableEventsArgsForCall = append(fake.getConsolidatedBillableEventsArgsForCall, struct {
		arg1 eventio.EventFilter
	}{arg1})
	stub := fake.GetConsolidatedBillableEventsStub
	fakeReturns := fake.getConsolidatedBillableEventsReturns
	fake.recordInvocation("GetConsolidatedBillableEvents", []interface{}{arg1})
	fake.getConsolidatedBillableEventsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeEventStore) GetConsolidatedBillableEventsCallCount() int {
	fake.getConsolidatedBillableEventsMutex.RLock()
	defer fake.getConsolidatedBillableEventsMutex.RUnlock()
	return len(fake.getConsolidatedBillableEventsArgsForCall)
}

func (fake *FakeEventStore) GetConsolidatedBillableEventsCalls(stub func(eventio.EventFilter) ([]eventio.BillableEvent, error)) {
	fake.getConsolidatedBillableEventsMutex.Lock()
	defer fake.getConsolidatedBillableEventsMutex.Unlock()
	fake.GetConsolidatedBillableEventsStub = stub
}

func (fake *FakeEventStore) GetConsolidatedBillableEventsArgsForCall(i int) eventio.EventFilter {
	fake.getConsolidatedBillableEventsMutex.RLock()
	defer fake.getConsolidatedBillableEventsMutex.RUnlock()
	argsForCall := fake.getConsolidatedBillableEventsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeEventStore) GetConsolidatedBillableEventsReturns(result1 []eventio.BillableEvent, result2 error) {
	fake.getConsolidatedBillableEventsMutex.Lock()
	defer fake.getConsolidatedBillableEventsMutex.Unlock()
	fake.GetConsolidatedBillableEventsStub = nil
	fake.getConsolidatedBillableEventsReturns = struct {
		result1 []eventio.BillableEvent
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) GetConsolidatedBillableEventsReturnsOnCall(i int, result1 []eventio.BillableEvent, result2 error) {
	fake.getConsolidatedBillableEventsMutex.Lock()
	defer fake.getConsolidatedBillableEventsMutex.Unlock()
	fake.GetConsolidatedBillableEventsStub = nil
	if fake.getConsolidatedBillableEventsReturnsOnCall == nil {
		fake.getConsolidatedBillableEventsReturnsOnCall = make(map[int]struct {
			result1 []eventio.BillableEvent
			result2 error
		})
	}
	fake.getConsolidatedBillableEventsReturnsOnCall[i] = struct {
		result1 []eventio.BillableEvent
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) GetCurrencyRates(arg1 eventio.TimeRangeFilter) ([]eventio.CurrencyRate, error) {
	fake.getCurrencyRatesMutex.Lock()
	ret, specificReturn := fake.getCurrencyRatesReturnsOnCall[len(fake.getCurrencyRatesArgsForCall)]
	fake.getCurrencyRatesArgsForCall = append(fake.getCurrencyRatesArgsForCall, struct {
		arg1 eventio.TimeRangeFilter
	}{arg1})
	stub := fake.GetCurrencyRatesStub
	fakeReturns := fake.getCurrencyRatesReturns
	fake.recordInvocation("GetCurrencyRates", []interface{}{arg1})
	fake.getCurrencyRatesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeEventStore) GetCurrencyRatesCallCount() int {
	fake.getCurrencyRatesMutex.RLock()
	defer fake.getCurrencyRatesMutex.RUnlock()
	return len(fake.getCurrencyRatesArgsForCall)
}

func (fake *FakeEventStore) GetCurrencyRatesCalls(stub func(eventio.TimeRangeFilter) ([]eventio.CurrencyRate, error)) {
	fake.getCurrencyRatesMutex.Lock()
	defer fake.getCurrencyRatesMutex.Unlock()
	fake.GetCurrencyRatesStub = stub
}

func (fake *FakeEventStore) GetCurrencyRatesArgsForCall(i int) eventio.TimeRangeFilter {
	fake.getCurrencyRatesMutex.RLock()
	defer fake.getCurrencyRatesMutex.RUnlock()
	argsForCall := fake.getCurrencyRatesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeEventStore) GetCurrencyRatesReturns(result1 []eventio.CurrencyRate, result2 error) {
	fake.getCurrencyRatesMutex.Lock()
	defer fake.getCurrencyRatesMutex.Unlock()
	fake.GetCurrencyRatesStub = nil
	fake.getCurrencyRatesReturns = struct {
		result1 []eventio.CurrencyRate
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) GetCurrencyRatesReturnsOnCall(i int, result1 []eventio.CurrencyRate, result2 error) {
	fake.getCurrencyRatesMutex.Lock()
	defer fake.getCurrencyRatesMutex.Unlock()
	fake.GetCurrencyRatesStub = nil
	if fake.getCurrencyRatesReturnsOnCall == nil {
		fake.getCurrencyRatesReturnsOnCall = make(map[int]struct {
			result1 []eventio.CurrencyRate
			result2 error
		})
	}
	fake.getCurrencyRatesReturnsOnCall[i] = struct {
		result1 []eventio.CurrencyRate
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) GetEvents(arg1 eventio.RawEventFilter) ([]eventio.RawEvent, error) {
	fake.getEventsMutex.Lock()
	ret, specificReturn := fake.getEventsReturnsOnCall[len(fake.getEventsArgsForCall)]
	fake.getEventsArgsForCall = append(fake.getEventsArgsForCall, struct {
		arg1 eventio.RawEventFilter
	}{arg1})
	stub := fake.GetEventsStub
	fakeReturns := fake.getEventsReturns
	fake.recordInvocation("GetEvents", []interface{}{arg1})
	fake.getEventsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeEventStore) GetEventsCallCount() int {
	fake.getEventsMutex.RLock()
	defer fake.getEventsMutex.RUnlock()
	return len(fake.getEventsArgsForCall)
}

func (fake *FakeEventStore) GetEventsCalls(stub func(eventio.RawEventFilter) ([]eventio.RawEvent, error)) {
	fake.getEventsMutex.Lock()
	defer fake.getEventsMutex.Unlock()
	fake.GetEventsStub = stub
}

func (fake *FakeEventStore) GetEventsArgsForCall(i int) eventio.RawEventFilter {
	fake.getEventsMutex.RLock()
	defer fake.getEventsMutex.RUnlock()
	argsForCall := fake.getEventsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeEventStore) GetEventsReturns(result1 []eventio.RawEvent, result2 error) {
	fake.getEventsMutex.Lock()
	defer fake.getEventsMutex.Unlock()
	fake.GetEventsStub = nil
	fake.getEventsReturns = struct {
		result1 []eventio.RawEvent
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) GetEventsReturnsOnCall(i int, result1 []eventio.RawEvent, result2 error) {
	fake.getEventsMutex.Lock()
	defer fake.getEventsMutex.Unlock()
	fake.GetEventsStub = nil
	if fake.getEventsReturnsOnCall == nil {
		fake.getEventsReturnsOnCall = make(map[int]struct {
			result1 []eventio.RawEvent
			result2 error
		})
	}
	fake.getEventsReturnsOnCall[i] = struct {
		result1 []eventio.RawEvent
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) GetPricingPlans(arg1 eventio.TimeRangeFilter) ([]eventio.PricingPlan, error) {
	fake.getPricingPlansMutex.Lock()
	ret, specificReturn := fake.getPricingPlansReturnsOnCall[len(fake.getPricingPlansArgsForCall)]
	fake.getPricingPlansArgsForCall = append(fake.getPricingPlansArgsForCall, struct {
		arg1 eventio.TimeRangeFilter
	}{arg1})
	stub := fake.GetPricingPlansStub
	fakeReturns := fake.getPricingPlansReturns
	fake.recordInvocation("GetPricingPlans", []interface{}{arg1})
	fake.getPricingPlansMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeEventStore) GetPricingPlansCallCount() int {
	fake.getPricingPlansMutex.RLock()
	defer fake.getPricingPlansMutex.RUnlock()
	return len(fake.getPricingPlansArgsForCall)
}

func (fake *FakeEventStore) GetPricingPlansCalls(stub func(eventio.TimeRangeFilter) ([]eventio.PricingPlan, error)) {
	fake.getPricingPlansMutex.Lock()
	defer fake.getPricingPlansMutex.Unlock()
	fake.GetPricingPlansStub = stub
}

func (fake *FakeEventStore) GetPricingPlansArgsForCall(i int) eventio.TimeRangeFilter {
	fake.getPricingPlansMutex.RLock()
	defer fake.getPricingPlansMutex.RUnlock()
	argsForCall := fake.getPricingPlansArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeEventStore) GetPricingPlansReturns(result1 []eventio.PricingPlan, result2 error) {
	fake.getPricingPlansMutex.Lock()
	defer fake.getPricingPlansMutex.Unlock()
	fake.GetPricingPlansStub = nil
	fake.getPricingPlansReturns = struct {
		result1 []eventio.PricingPlan
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) GetPricingPlansReturnsOnCall(i int, result1 []eventio.PricingPlan, result2 error) {
	fake.getPricingPlansMutex.Lock()
	defer fake.getPricingPlansMutex.Unlock()
	fake.GetPricingPlansStub = nil
	if fake.getPricingPlansReturnsOnCall == nil {
		fake.getPricingPlansReturnsOnCall = make(map[int]struct {
			result1 []eventio.PricingPlan
			result2 error
		})
	}
	fake.getPricingPlansReturnsOnCall[i] = struct {
		result1 []eventio.PricingPlan
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) GetTotalCost() ([]eventio.TotalCost, error) {
	fake.getTotalCostMutex.Lock()
	ret, specificReturn := fake.getTotalCostReturnsOnCall[len(fake.getTotalCostArgsForCall)]
	fake.getTotalCostArgsForCall = append(fake.getTotalCostArgsForCall, struct {
	}{})
	stub := fake.GetTotalCostStub
	fakeReturns := fake.getTotalCostReturns
	fake.recordInvocation("GetTotalCost", []interface{}{})
	fake.getTotalCostMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeEventStore) GetTotalCostCallCount() int {
	fake.getTotalCostMutex.RLock()
	defer fake.getTotalCostMutex.RUnlock()
	return len(fake.getTotalCostArgsForCall)
}

func (fake *FakeEventStore) GetTotalCostCalls(stub func() ([]eventio.TotalCost, error)) {
	fake.getTotalCostMutex.Lock()
	defer fake.getTotalCostMutex.Unlock()
	fake.GetTotalCostStub = stub
}

func (fake *FakeEventStore) GetTotalCostReturns(result1 []eventio.TotalCost, result2 error) {
	fake.getTotalCostMutex.Lock()
	defer fake.getTotalCostMutex.Unlock()
	fake.GetTotalCostStub = nil
	fake.getTotalCostReturns = struct {
		result1 []eventio.TotalCost
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) GetTotalCostReturnsOnCall(i int, result1 []eventio.TotalCost, result2 error) {
	fake.getTotalCostMutex.Lock()
	defer fake.getTotalCostMutex.Unlock()
	fake.GetTotalCostStub = nil
	if fake.getTotalCostReturnsOnCall == nil {
		fake.getTotalCostReturnsOnCall = make(map[int]struct {
			result1 []eventio.TotalCost
			result2 error
		})
	}
	fake.getTotalCostReturnsOnCall[i] = struct {
		result1 []eventio.TotalCost
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) GetUsageEventRows(arg1 eventio.EventFilter) (eventio.UsageEventRows, error) {
	fake.getUsageEventRowsMutex.Lock()
	ret, specificReturn := fake.getUsageEventRowsReturnsOnCall[len(fake.getUsageEventRowsArgsForCall)]
	fake.getUsageEventRowsArgsForCall = append(fake.getUsageEventRowsArgsForCall, struct {
		arg1 eventio.EventFilter
	}{arg1})
	stub := fake.GetUsageEventRowsStub
	fakeReturns := fake.getUsageEventRowsReturns
	fake.recordInvocation("GetUsageEventRows", []interface{}{arg1})
	fake.getUsageEventRowsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeEventStore) GetUsageEventRowsCallCount() int {
	fake.getUsageEventRowsMutex.RLock()
	defer fake.getUsageEventRowsMutex.RUnlock()
	return len(fake.getUsageEventRowsArgsForCall)
}

func (fake *FakeEventStore) GetUsageEventRowsCalls(stub func(eventio.EventFilter) (eventio.UsageEventRows, error)) {
	fake.getUsageEventRowsMutex.Lock()
	defer fake.getUsageEventRowsMutex.Unlock()
	fake.GetUsageEventRowsStub = stub
}

func (fake *FakeEventStore) GetUsageEventRowsArgsForCall(i int) eventio.EventFilter {
	fake.getUsageEventRowsMutex.RLock()
	defer fake.getUsageEventRowsMutex.RUnlock()
	argsForCall := fake.getUsageEventRowsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeEventStore) GetUsageEventRowsReturns(result1 eventio.UsageEventRows, result2 error) {
	fake.getUsageEventRowsMutex.Lock()
	defer fake.getUsageEventRowsMutex.Unlock()
	fake.GetUsageEventRowsStub = nil
	fake.getUsageEventRowsReturns = struct {
		result1 eventio.UsageEventRows
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) GetUsageEventRowsReturnsOnCall(i int, result1 eventio.UsageEventRows, result2 error) {
	fake.getUsageEventRowsMutex.Lock()
	defer fake.getUsageEventRowsMutex.Unlock()
	fake.GetUsageEventRowsStub = nil
	if fake.getUsageEventRowsReturnsOnCall == nil {
		fake.getUsageEventRowsReturnsOnCall = make(map[int]struct {
			result1 eventio.UsageEventRows
			result2 error
		})
	}
	fake.getUsageEventRowsReturnsOnCall[i] = struct {
		result1 eventio.UsageEventRows
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) GetUsageEvents(arg1 eventio.EventFilter) ([]eventio.UsageEvent, error) {
	fake.getUsageEventsMutex.Lock()
	ret, specificReturn := fake.getUsageEventsReturnsOnCall[len(fake.getUsageEventsArgsForCall)]
	fake.getUsageEventsArgsForCall = append(fake.getUsageEventsArgsForCall, struct {
		arg1 eventio.EventFilter
	}{arg1})
	stub := fake.GetUsageEventsStub
	fakeReturns := fake.getUsageEventsReturns
	fake.recordInvocation("GetUsageEvents", []interface{}{arg1})
	fake.getUsageEventsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeEventStore) GetUsageEventsCallCount() int {
	fake.getUsageEventsMutex.RLock()
	defer fake.getUsageEventsMutex.RUnlock()
	return len(fake.getUsageEventsArgsForCall)
}

func (fake *FakeEventStore) GetUsageEventsCalls(stub func(eventio.EventFilter) ([]eventio.UsageEvent, error)) {
	fake.getUsageEventsMutex.Lock()
	defer fake.getUsageEventsMutex.Unlock()
	fake.GetUsageEventsStub = stub
}

func (fake *FakeEventStore) GetUsageEventsArgsForCall(i int) eventio.EventFilter {
	fake.getUsageEventsMutex.RLock()
	defer fake.getUsageEventsMutex.RUnlock()
	argsForCall := fake.getUsageEventsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeEventStore) GetUsageEventsReturns(result1 []eventio.UsageEvent, result2 error) {
	fake.getUsageEventsMutex.Lock()
	defer fake.getUsageEventsMutex.Unlock()
	fake.GetUsageEventsStub = nil
	fake.getUsageEventsReturns = struct {
		result1 []eventio.UsageEvent
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) GetUsageEventsReturnsOnCall(i int, result1 []eventio.UsageEvent, result2 error) {
	fake.getUsageEventsMutex.Lock()
	defer fake.getUsageEventsMutex.Unlock()
	fake.GetUsageEventsStub = nil
	if fake.getUsageEventsReturnsOnCall == nil {
		fake.getUsageEventsReturnsOnCall = make(map[int]struct {
			result1 []eventio.UsageEvent
			result2 error
		})
	}
	fake.getUsageEventsReturnsOnCall[i] = struct {
		result1 []eventio.UsageEvent
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) GetVATRates(arg1 eventio.TimeRangeFilter) ([]eventio.VATRate, error) {
	fake.getVATRatesMutex.Lock()
	ret, specificReturn := fake.getVATRatesReturnsOnCall[len(fake.getVATRatesArgsForCall)]
	fake.getVATRatesArgsForCall = append(fake.getVATRatesArgsForCall, struct {
		arg1 eventio.TimeRangeFilter
	}{arg1})
	stub := fake.GetVATRatesStub
	fakeReturns := fake.getVATRatesReturns
	fake.recordInvocation("GetVATRates", []interface{}{arg1})
	fake.getVATRatesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeEventStore) GetVATRatesCallCount() int {
	fake.getVATRatesMutex.RLock()
	defer fake.getVATRatesMutex.RUnlock()
	return len(fake.getVATRatesArgsForCall)
}

func (fake *FakeEventStore) GetVATRatesCalls(stub func(eventio.TimeRangeFilter) ([]eventio.VATRate, error)) {
	fake.getVATRatesMutex.Lock()
	defer fake.getVATRatesMutex.Unlock()
	fake.GetVATRatesStub = stub
}

func (fake *FakeEventStore) GetVATRatesArgsForCall(i int) eventio.TimeRangeFilter {
	fake.getVATRatesMutex.RLock()
	defer fake.getVATRatesMutex.RUnlock()
	argsForCall := fake.getVATRatesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeEventStore) GetVATRatesReturns(result1 []eventio.VATRate, result2 error) {
	fake.getVATRatesMutex.Lock()
	defer fake.getVATRatesMutex.Unlock()
	fake.GetVATRatesStub = nil
	fake.getVATRatesReturns = struct {
		result1 []eventio.VATRate
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) GetVATRatesReturnsOnCall(i int, result1 []eventio.VATRate, result2 error) {
	fake.getVATRatesMutex.Lock()
	defer fake.getVATRatesMutex.Unlock()
	fake.GetVATRatesStub = nil
	if fake.getVATRatesReturnsOnCall == nil {
		fake.getVATRatesReturnsOnCall = make(map[int]struct {
			result1 []eventio.VATRate
			result2 error
		})
	}
	fake.getVATRatesReturnsOnCall[i] = struct {
		result1 []eventio.VATRate
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) Init() error {
	fake.initMutex.Lock()
	ret, specificReturn := fake.initReturnsOnCall[len(fake.initArgsForCall)]
	fake.initArgsForCall = append(fake.initArgsForCall, struct {
	}{})
	stub := fake.InitStub
	fakeReturns := fake.initReturns
	fake.recordInvocation("Init", []interface{}{})
	fake.initMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeEventStore) InitCallCount() int {
	fake.initMutex.RLock()
	defer fake.initMutex.RUnlock()
	return len(fake.initArgsForCall)
}

func (fake *FakeEventStore) InitCalls(stub func() error) {
	fake.initMutex.Lock()
	defer fake.initMutex.Unlock()
	fake.InitStub = stub
}

func (fake *FakeEventStore) InitReturns(result1 error) {
	fake.initMutex.Lock()
	defer fake.initMutex.Unlock()
	fake.InitStub = nil
	fake.initReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeEventStore) InitReturnsOnCall(i int, result1 error) {
	fake.initMutex.Lock()
	defer fake.initMutex.Unlock()
	fake.InitStub = nil
	if fake.initReturnsOnCall == nil {
		fake.initReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.initReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeEventStore) IsRangeConsolidated(arg1 eventio.EventFilter) (bool, error) {
	fake.isRangeConsolidatedMutex.Lock()
	ret, specificReturn := fake.isRangeConsolidatedReturnsOnCall[len(fake.isRangeConsolidatedArgsForCall)]
	fake.isRangeConsolidatedArgsForCall = append(fake.isRangeConsolidatedArgsForCall, struct {
		arg1 eventio.EventFilter
	}{arg1})
	stub := fake.IsRangeConsolidatedStub
	fakeReturns := fake.isRangeConsolidatedReturns
	fake.recordInvocation("IsRangeConsolidated", []interface{}{arg1})
	fake.isRangeConsolidatedMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeEventStore) IsRangeConsolidatedCallCount() int {
	fake.isRangeConsolidatedMutex.RLock()
	defer fake.isRangeConsolidatedMutex.RUnlock()
	return len(fake.isRangeConsolidatedArgsForCall)
}

func (fake *FakeEventStore) IsRangeConsolidatedCalls(stub func(eventio.EventFilter) (bool, error)) {
	fake.isRangeConsolidatedMutex.Lock()
	defer fake.isRangeConsolidatedMutex.Unlock()
	fake.IsRangeConsolidatedStub = stub
}

func (fake *FakeEventStore) IsRangeConsolidatedArgsForCall(i int) eventio.EventFilter {
	fake.isRangeConsolidatedMutex.RLock()
	defer fake.isRangeConsolidatedMutex.RUnlock()
	argsForCall := fake.isRangeConsolidatedArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeEventStore) IsRangeConsolidatedReturns(result1 bool, result2 error) {
	fake.isRangeConsolidatedMutex.Lock()
	defer fake.isRangeConsolidatedMutex.Unlock()
	fake.IsRangeConsolidatedStub = nil
	fake.isRangeConsolidatedReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) IsRangeConsolidatedReturnsOnCall(i int, result1 bool, result2 error) {
	fake.isRangeConsolidatedMutex.Lock()
	defer fake.isRangeConsolidatedMutex.Unlock()
	fake.IsRangeConsolidatedStub = nil
	if fake.isRangeConsolidatedReturnsOnCall == nil {
		fake.isRangeConsolidatedReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.isRangeConsolidatedReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeEventStore) Ping() error {
	fake.pingMutex.Lock()
	ret, specificReturn := fake.pingReturnsOnCall[len(fake.pingArgsForCall)]
	fake.pingArgsForCall = append(fake.pingArgsForCall, struct {
	}{})
	stub := fake.PingStub
	fakeReturns := fake.pingReturns
	fake.recordInvocation("Ping", []interface{}{})
	fake.pingMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeEventStore) PingCallCount() int {
	fake.pingMutex.RLock()
	defer fake.pingMutex.RUnlock()
	return len(fake.pingArgsForCall)
}

func (fake *FakeEventStore) PingCalls(stub func() error) {
	fake.pingMutex.Lock()
	defer fake.pingMutex.Unlock()
	fake.PingStub = stub
}

func (fake *FakeEventStore) PingReturns(result1 error) {
	fake.pingMutex.Lock()
	defer fake.pingMutex.Unlock()
	fake.PingStub = nil
	fake.pingReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeEventStore) PingReturnsOnCall(i int, result1 error) {
	fake.pingMutex.Lock()
	defer fake.pingMutex.Unlock()
	fake.PingStub = nil
	if fake.pingReturnsOnCall == nil {
		fake.pingReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pingReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeEventStore) Refresh() error {
	fake.refreshMutex.Lock()
	ret, specificReturn := fake.refreshReturnsOnCall[len(fake.refreshArgsForCall)]
	fake.refreshArgsForCall = append(fake.refreshArgsForCall, struct {
	}{})
	stub := fake.RefreshStub
	fakeReturns := fake.refreshReturns
	fake.recordInvocation("Refresh", []interface{}{})
	fake.refreshMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeEventStore) RefreshCallCount() int {
	fake.refreshMutex.RLock()
	defer fake.refreshMutex.RUnlock()
	return len(fake.refreshArgsForCall)
}

func (fake *FakeEventStore) RefreshCalls(stub func() error) {
	fake.refreshMutex.Lock()
	defer fake.refreshMutex.Unlock()
	fake.RefreshStub = stub
}

func (fake *FakeEventStore) RefreshReturns(result1 error) {
	fake.refreshMutex.Lock()
	defer fake.refreshMutex.Unlock()
	fake.RefreshStub = nil
	fake.refreshReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeEventStore) RefreshReturnsOnCall(i int, result1 error) {
	fake.refreshMutex.Lock()
	defer fake.refreshMutex.Unlock()
	fake.RefreshStub = nil
	if fake.refreshReturnsOnCall == nil {
		fake.refreshReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.refreshReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeEventStore) StoreEvents(arg1 []eventio.RawEvent) error {
	var arg1Copy []eventio.RawEvent
	if arg1 != nil {
		arg1Copy = make([]eventio.RawEvent, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.storeEventsMutex.Lock()
	ret, specificReturn := fake.storeEventsReturnsOnCall[len(fake.storeEventsArgsForCall)]
	fake.storeEventsArgsForCall = append(fake.storeEventsArgsForCall, struct {
		arg1 []eventio.RawEvent
	}{arg1Copy})
	stub := fake.StoreEventsStub
	fakeReturns := fake.storeEventsReturns
	fake.recordInvocation("StoreEvents", []interface{}{arg1Copy})
	fake.storeEventsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeEventStore) StoreEventsCallCount() int {
	fake.storeEventsMutex.RLock()
	defer fake.storeEventsMutex.RUnlock()
	return len(fake.storeEventsArgsForCall)
}

func (fake *FakeEventStore) StoreEventsCalls(stub func([]eventio.RawEvent) error) {
	fake.storeEventsMutex.Lock()
	defer fake.storeEventsMutex.Unlock()
	fake.StoreEventsStub = stub
}

func (fake *FakeEventStore) StoreEventsArgsForCall(i int) []eventio.RawEvent {
	fake.storeEventsMutex.RLock()
	defer fake.storeEventsMutex.RUnlock()
	argsForCall := fake.storeEventsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeEventStore) StoreEventsReturns(result1 error) {
	fake.storeEventsMutex.Lock()
	defer fake.storeEventsMutex.Unlock()
	fake.StoreEventsStub = nil
	fake.storeEventsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeEventStore) StoreEventsReturnsOnCall(i int, result1 error) {
	fake.storeEventsMutex.Lock()
	defer fake.storeEventsMutex.Unlock()
	fake.StoreEventsStub = nil
	if fake.storeEventsReturnsOnCall == nil {
		fake.storeEventsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.storeEventsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeEventStore) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.consolidateMutex.RLock()
	defer fake.consolidateMutex.RUnlock()
	fake.consolidateAllMutex.RLock()
	defer fake.consolidateAllMutex.RUnlock()
	fake.consolidateFullMonthsMutex.RLock()
	defer fake.consolidateFullMonthsMutex.RUnlock()
	fake.forecastBillableEventRowsMutex.RLock()
	defer fake.forecastBillableEventRowsMutex.RUnlock()
	fake.forecastBillableEventsMutex.RLock()
	defer fake.forecastBillableEventsMutex.RUnlock()
	fake.getBillableEventRowsMutex.RLock()
	defer fake.getBillableEventRowsMutex.RUnlock()
	fake.getBillableEventsMutex.RLock()
	defer fake.getBillableEventsMutex.RUnlock()
	fake.getConsolidatedBillableEventRowsMutex.RLock()
	defer fake.getConsolidatedBillableEventRowsMutex.RUnlock()
	fake.getConsolidatedBillableEventsMutex.RLock()
	defer fake.getConsolidatedBillableEventsMutex.RUnlock()
	fake.getCurrencyRatesMutex.RLock()
	defer fake.getCurrencyRatesMutex.RUnlock()
	fake.getEventsMutex.RLock()
	defer fake.getEventsMutex.RUnlock()
	fake.getPricingPlansMutex.RLock()
	defer fake.getPricingPlansMutex.RUnlock()
	fake.getTotalCostMutex.RLock()
	defer fake.getTotalCostMutex.RUnlock()
	fake.getUsageEventRowsMutex.RLock()
	defer fake.getUsageEventRowsMutex.RUnlock()
	fake.getUsageEventsMutex.RLock()
	defer fake.getUsageEventsMutex.RUnlock()
	fake.getVATRatesMutex.RLock()
	defer fake.getVATRatesMutex.RUnlock()
	fake.initMutex.RLock()
	defer fake.initMutex.RUnlock()
	fake.isRangeConsolidatedMutex.RLock()
	defer fake.isRangeConsolidatedMutex.RUnlock()
	fake.pingMutex.RLock()
	defer fake.pingMutex.RUnlock()
	fake.refreshMutex.RLock()
	defer fake.refreshMutex.RUnlock()
	fake.storeEventsMutex.RLock()
	defer fake.storeEventsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeEventStore) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ eventio.EventStore = new(FakeEventStore)
